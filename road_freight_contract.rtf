{\rtf1\ansi\deff0
{\fonttbl{\f0 Calibri;}{\f1 Courier New;}}
\fs36\b RoadFreight Smart Contract (Soroban / Stellar)\b0\par
\fs20 Generated: 2025-10-18 08:50\par\par
\fs28\b HƯỚNG DẪN CHẠY\par\b0\fs20
HƯỚNG DẪN CHẠY (CLI v23.1.4)\par
\par
1) Build .wasm\par
   - cd /Users/macbook/hello-stellar\par
   - cargo build --target wasm32-unknown-unknown --release\par
\par
   (tuỳ chọn) Optimize:\par
   - stellar contract optimize \\\par
       --wasm target/wasm32-unknown-unknown/release/road_freight.wasm \\\par
       --wasm-out target/optimized/road_freight.wasm\par
   - Chọn một file để deploy: target/optimized/road_freight.wasm\par
     hoặc target/wasm32-unknown-unknown/release/road_freight.wasm\par
\par
2) Tạo ví dev (1 lần duy nhất) và nạp XLM testnet\par
   - stellar keys generate dev-id\par
   - ADDR=$(stellar keys address dev-id)\par
   - Truy cập: https://friendbot.stellar.org/?addr=$ADDR  (để nhận 10,000 XLM testnet)\par
\par
3) Deploy lên Testnet\par
   - WASM=target/optimized/road_freight.wasm  (hoặc bản release)\par
   - CONTRACT_ID=$(stellar contract deploy --wasm "$WASM" --network testnet --source dev-id)\par
   - echo $CONTRACT_ID\par
\par
4) Invoke theo luồng nghiệp vụ (demo)\par
   - SHIP=$(stellar keys address dev-id)\par
   - CAR=$SHIP\par
   - TOKEN=$CONTRACT_ID\par
   - DOC=0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\par
   - POD=0xbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\par
   - DEADLINE=$(( $(date +%s) + 3600 ))\par
   - PRICE=1000000\par
\par
   (1) Tạo hợp đồng\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     create_contract \\\par
     --shipper "$SHIP" --carrier "$CAR" \\\par
     --origin "ICD A" --destination "ICD B" \\\par
     --token "$TOKEN" --price $PRICE \\\par
     --deadline_unix $DEADLINE --doc_hash $DOC\par
\par
   (2) Carrier chấp nhận\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     accept --id 1 --carrier "$CAR"\par
\par
   (3) Đánh dấu đã ký quỹ (demo)\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     mark_funded --id 1 --shipper "$SHIP"\par
\par
   (4) Bắt đầu chuyến\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     start_trip --id 1 --caller "$SHIP"\par
\par
   (5) Log telemetry\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     log_telemetry --id 1 --add_secs 600 --add_km 12 --add_cost 25000 --oracle "$SHIP"\par
\par
   (6) Nộp POD\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     submit_pod --id 1 --pod_hash $POD --caller "$CAR"\par
\par
   (7) Đánh giá & “thanh toán” (demo)\par
   stellar contract invoke --id $CONTRACT_ID --network testnet --source dev-id -- \\\par
     evaluate_and_settle --id 1 --invoker "$SHIP"\par
\par
   (8) Đọc lại state\par
   stellar contract invoke --id $CONTRACT_ID --network testnet -- \\\par
     get_contract --id 1\par
\par
\fs28\b MÃ NGUỒN: src/lib.rs\par\b0\fs18
{\pard\li360\sa120\f1\fs18
#![no_std]\line 
\line 
use soroban_sdk::\{\line 
    contract, contracterror, contractimpl, contracttype, symbol_short,\line 
    Address, BytesN, Env, String,\line 
\};\line 
\line 
#[contracterror]\line 
#[derive(Copy, Clone, Debug, Eq, PartialEq)]\line 
pub enum Error \{\line 
    Unauthorized = 1,\line 
    NotFound = 2,\line 
    BadState = 3,\line 
    EscrowNotFunded = 4,\line 
    AlreadySettled = 5,\line 
\}\line 
\line 
#[contracttype]\line 
#[derive(Clone)]\line 
pub enum Status \{\line 
    Draft,\line 
    Active,\line 
    InTransit,\line 
    Delivered,\line 
    Settled,\line 
\}\line 
\line 
#[contracttype]\line 
#[derive(Clone)]\line 
pub struct FreightContract \{\line 
    pub id: u128,\line 
    pub shipper: Address,\line 
    pub carrier: Address,\line 
    pub origin: String,\line 
    pub destination: String,\line 
    pub token: Address,      \line 
    pub price: i128,\line 
    pub deadline_unix: u64,\line 
    pub doc_hash: BytesN<32>,\line 
    pub status: Status,\line 
    pub created_at: u64,\line 
    pub escrow_funded: bool,\line 
    pub total_secs: u64,\line 
    pub total_km: u32,\line 
    pub computed_cost: i128,\line 
    pub last_paid: i128,      // demo: ghi số tiền "đã trả"\line 
\}\line 
\line 
#[contracttype]\line 
enum DataKey \{\line 
    NextId,\line 
    Contract(u128),\line 
\}\line 
\line 
fn put<T: soroban_sdk::IntoVal<Env, soroban_sdk::Val>>(e: &Env, k: &DataKey, v: &T) \{\line 
    e.storage().instance().set(k, v);\line 
    e.storage().instance().extend_ttl(50, 200);\line 
\}\line 
fn get<T: soroban_sdk::TryFromVal<Env, soroban_sdk::Val>>(e: &Env, k: &DataKey) -> Option<T> \{\line 
    e.storage().instance().get(k)\line 
\}\line 
\line 
#[contract]\line 
pub struct RoadFreight;\line 
\line 
#[contractimpl]\line 
impl RoadFreight \{\line 
    fn next_id(e: &Env) -> u128 \{\line 
        let mut id: u128 = e.storage().instance().get(&DataKey::NextId).unwrap_or(0_u128);\line 
        id += 1;\line 
        put(e, &DataKey::NextId, &id);\line 
        id\line 
    \}\line 
\line 
    #[allow(clippy::too_many_arguments)]\line 
    pub fn create_contract(\line 
        e: Env,\line 
        shipper: Address,\line 
        carrier: Address,\line 
        origin: String,\line 
        destination: String,\line 
        token: Address,\line 
        price: i128,\line 
        deadline_unix: u64,\line 
        doc_hash: BytesN<32>,\line 
    ) -> Result<u128, Error> \{\line 
        shipper.require_auth();\line 
\line 
        let id = Self::next_id(&e);\line 
        let fc = FreightContract \{\line 
            id,\line 
            shipper: shipper.clone(),\line 
            carrier: carrier.clone(),\line 
            origin,\line 
            destination,\line 
            token,\line 
            price,\line 
            deadline_unix,\line 
            doc_hash,\line 
            status: Status::Draft,\line 
            created_at: e.ledger().timestamp(),\line 
            escrow_funded: false,\line 
            total_secs: 0,\line 
            total_km: 0,\line 
            computed_cost: 0,\line 
            last_paid: 0,\line 
        \};\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
\line 
        // publish(topics, data) — 2 tham số\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("CREATED")), id);\line 
        Ok(id)\line 
    \}\line 
\line 
    pub fn accept(e: Env, id: u128, carrier: Address) -> Result<(), Error> \{\line 
        carrier.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if fc.carrier != carrier \{ return Err(Error::Unauthorized); \}\line 
        if !matches!(fc.status, Status::Draft) \{ return Err(Error::BadState); \}\line 
\line 
        fc.status = Status::Active;\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("ACCEPTED")), id);\line 
        Ok(())\line 
    \}\line 
\line 
    // Demo: tạm đánh dấu đã ký quỹ (chưa chuyển token thật)\line 
    pub fn mark_funded(e: Env, id: u128, shipper: Address) -> Result<(), Error> \{\line 
        shipper.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if fc.shipper != shipper \{ return Err(Error::Unauthorized); \}\line 
        if !matches!(fc.status, Status::Active) \{ return Err(Error::BadState); \}\line 
\line 
        fc.escrow_funded = true;\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("FUNDED")), id);\line 
        Ok(())\line 
    \}\line 
\line 
    pub fn start_trip(e: Env, id: u128, caller: Address) -> Result<(), Error> \{\line 
        caller.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if !(caller == fc.shipper || caller == fc.carrier) \{ return Err(Error::Unauthorized); \}\line 
        if !matches!(fc.status, Status::Active) \{ return Err(Error::BadState); \}\line 
        if !fc.escrow_funded \{ return Err(Error::EscrowNotFunded); \}\line 
\line 
        fc.status = Status::InTransit;\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("STARTED")), id);\line 
        Ok(())\line 
    \}\line 
\line 
    pub fn log_telemetry(\line 
        e: Env,\line 
        id: u128,\line 
        add_secs: u32,\line 
        add_km: u32,\line 
        add_cost: i128,\line 
        oracle: Address,\line 
    ) -> Result<(), Error> \{\line 
        oracle.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if !matches!(fc.status, Status::InTransit) \{ return Err(Error::BadState); \}\line 
\line 
        fc.total_secs = fc.total_secs.saturating_add(add_secs as u64);\line 
        fc.total_km   = fc.total_km.saturating_add(add_km);\line 
        fc.computed_cost = fc.computed_cost.saturating_add(add_cost);\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("TEL")), (id, add_secs, add_km));\line 
        Ok(())\line 
    \}\line 
\line 
    pub fn submit_pod(e: Env, id: u128, pod_hash: BytesN<32>, caller: Address) -> Result<(), Error> \{\line 
        caller.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if !(caller == fc.shipper || caller == fc.carrier) \{ return Err(Error::Unauthorized); \}\line 
        if !matches!(fc.status, Status::InTransit) \{ return Err(Error::BadState); \}\line 
\line 
        fc.doc_hash = pod_hash.clone();\line 
        fc.status = Status::Delivered;\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("DELIVERED")), id);\line 
        Ok(())\line 
    \}\line 
\line 
    pub fn evaluate_and_settle(e: Env, id: u128, invoker: Address) -> Result<i128, Error> \{\line 
        invoker.require_auth();\line 
        let mut fc: FreightContract = get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)?;\line 
        if !matches!(fc.status, Status::Delivered) \{ return Err(Error::BadState); \}\line 
        if !fc.escrow_funded \{ return Err(Error::EscrowNotFunded); \}\line 
\line 
        let now = e.ledger().timestamp();\line 
        let pay = if now <= fc.deadline_unix \{ fc.price \} else \{ fc.price / 2 \};\line 
\line 
        fc.status = Status::Settled;\line 
        fc.last_paid = pay;\line 
        put(&e, &DataKey::Contract(id), &fc);\line 
\line 
        e.events().publish((symbol_short!("EV"), symbol_short!("SETTLED")), (id, pay));\line 
        Ok(pay)\line 
    \}\line 
\line 
    pub fn get_contract(e: Env, id: u128) -> Result<FreightContract, Error> \{\line 
        get(&e, &DataKey::Contract(id)).ok_or(Error::NotFound)\line 
    \}\line 
\}\line 
}
}